## 一、实验原理

### 1、riscv64 中断介绍

#### 1.1 中断概念

##### 1.1.1 定义：

- 中断（interrupt）：就是不管CPU现在手里在干啥活，收到“中断”的时候，都先放下来去处理其他事情，处理完其他事情可能再回来干手头的活。中断机制需要软件硬件一起来支持。硬件进行中断和异常的发现，然后交给软件来进行处理。

##### 1.1.2分类：

​	中断（interrupt）可以分为以下三类：

- **异常**(Exception)，指在执行一条指令的过程中发生了错误，此时我们通过中断来处理错误。最常见的异常包括：访问无效内存地址、执行非法指令(除零)、发生缺页等。他们有的可以恢复(如缺页)，有的不可恢复(如除零)，只能终止程序执行。
- **陷入**(Trap)，指我们主动通过一条指令停下来，并跳转到处理函数。常见的形式有通过`ecall`进行系统调用(syscall)，或通过`ebreak`进入断点(breakpoint)。
- **外部中断**(Interrupt)，简称中断，指的是 CPU 的执行过程被外设发来的信号打断，此时我们必须先停下来对该外设进行处理。典型的有定时器倒计时结束、串口收到数据等。外部中断是异步(asynchronous)的，CPU 并不知道外部中断将何时发生。CPU 也并不需要一直在原地等着外部中断的发生，而是执行代码，有了外部中断才去处理。我们知道，CPU 的主频远高于 I/O 设备，这样避免了 CPU 资源的浪费。

​	对于中断的补充：

- 由于中断处理需要进行较高权限的操作，中断处理一般位于**内核态**，或者中断处理处于“比被打断的程序更高的特权级”。
- 在RISCV中，中断（interrupt）和异常（exception）统称为trap。

| 层级   | 模式       | 作用                                    | 谁控制谁                      |
| ------ | ---------- | --------------------------------------- | ----------------------------- |
| M 模式 | Machine    | 固件/硬件管理层，对中断分配有最终决定权 | 控制下面所有层                |
| S 模式 | Supervisor | 操作系统内核（比如 Linux）              | 被 M 模式允许后接管用户态异常 |
| U 模式 | User       | 普通应用程序                            | 只能通过系统调用请求服务      |

（三种模式的控制权限关系大致如此）



#### 1.2 riscv64权限模式

##### 1.2.1 risc-v的三个特权级

- **M 模式（Machine Mode）**：是 RISC-V 中最高的特权级。在 M 模式下，hart（硬件线程）对内存、I/O 和底层功能有完全的控制权。默认情况下，所有的中断和异常都会首先进入 M 模式处理。M 模式是所有标准 RISC-V 处理器必须实现的特权级，通常用于处理器启动、底层固件（如 OpenSBI）的执行。
- **S 模式（Supervisor Mode）**：是支持现代类 Unix 操作系统的特权级。操作系统内核运行在 S 模式，它支持基于页面的虚拟内存机制，使得多任务和内存隔离成为可能。在 Unix 系统中，大多数系统调用和异常都在 S 模式下处理。
- **U 模式（User Mode）**：是最低的特权级。用户程序运行在 U 模式，只能执行普通指令，不能直接访问硬件或执行特权操作。当用户程序需要操作系统服务时，必须通过系统调用（`ecall` 指令）陷入到 S 模式。

（注："ecall"指令表示向更高特权级请求服务的陷阱指令。并不一定是到S特权级，分情况讨论。）

#### 1.3 中断的路由：从默认路径到委托机制

​	中断和委托在RISC-V框架下处理机制的核心：**中断或异常可以发生在处理器执行时的任何特权级**。发生在特定特权级的事件由哪个特权级的代码来处理是由RISC-V灵活的中断委托机制与系统软件的设计共同决定的。

​	具体处理分情况讨论：

##### 1.3.1 默认情况：

​	在默认情况下，RISC-V遵循最保守的安全设计：**所有中断与异常都会首先陷入最高特权级—— M 模式**。M模式作为硬件的直接管理者，保证了系统的安全，但是所有中断都由M模式处理，会带来不必要的性能开销和灵活性限制。

##### 1.3.2 改进情况：

​	为解决这个问题，RISC-V引入了**中断委托机制**，M模式设置两个关键寄存器，将特定的中断和异常处理权限交给S模式：

- mideleg(Machine Interrupt Delegation Register)：负责委托**中断**。例如，将软件中断、定时器中断或外部中断委托给S模式。
- medeleg(Machine Exception Delegation Register)：负责委托**异常**。例如，将用户态环境调用、非法指令、页错误等异常委托给S模式。

​	为了理解U、S、M三层模式执行自己的职责构成的架构，实验指导书中也提出以下的流程：

- U模式触发中断：这是最常见的情况。当用户程序执行 ecall 指令发起系统调用，或执行指令时发生页错误，该异常会被 medeleg 委托。硬件将直接陷入到S模式，而不再经过M模式。这是操作系统为用户提供服务的主要通道。
- S模式触发中断：内核自身在运行时也可能遇到两种性质不同的陷阱。第一种是 被动陷入 ，例如设备I/O完成产生的外部中断，或内核代码触发的缺页异常（内核本身一般不引发缺页异常，但是在尝试访问用户空间传入的数据的时候，也可能触发）。如果该中断类型已被委托，则处理流程为S模式陷入到S模式——这被称为“自陷”。第二种是 主动陷入 ，当内核需要访问硬件特权功能（如设置定时器）时，它会主动执行ecall指令。此时，由于ecall在S模式下执行，特权级将从S模式提升至M模式，由M模式的固件（如OpenSBI）提供服务，处理完毕后再通过mret指令返回S模式。
- M模式触发中断：某些与最底层硬件管理紧密相关的中断，例如M模式的定时器中断或某些安全性事件，通常不会被委托。它们始终在M模式内处理，由固件负责，这与操作系统的常规运行无关。



总的说来，RISC-V的委托机制是为了在保持硬件主控安全的前提下，让操作系统能直接高效地处理属于自己的中断和异常，从而在“安全”和“性能”之间取得最佳平衡。



#### 1.4 S模式的中断处理框架

##### 	1.4.1 stvec

​	stvec寄存器职责是“当处理器收到一个中断或异常，stvec首先决定跳到哪里执行处理代码”。stvec寄存器是一个 S 模式下的陷阱向量基址寄存器。具体结构如下列所示：

| 位范围        | 含义                                 |
| ------------- | ------------------------------------ |
| [SXLEN‒1 : 2] | 存放基址（trap vector base address） |
| [1 : 0]       | 模式（mode）标志位                   |

其中mode的两种情况：

| 模式编码 | 值            | 含义                                                        |
| -------- | ------------- | ----------------------------------------------------------- |
| 00       | Direct 模式   | 所有陷阱都跳转到同一个入口地址（通用 Trap 处理函数）        |
| 01       | Vectored 模式 | 根据 `scause` 的异常/中断号计算偏移，从而跳到不同的中断入口 |

##### 	1.4.2 硬件记录信息

​	在中断或异常发生，CPU跳转到stvec指定的处理程序之前，硬件会自动把关键信息记录在三个S级寄存器：

| 寄存器                               | 含义                                                       | 类比                           |
| ------------------------------------ | ---------------------------------------------------------- | ------------------------------ |
| `sepc` (Supervisor Exception PC)     | 保存“被中断的那条指令的地址”。恢复执行时需要跳回这个地址。 | 记录“出事现场的坐标”           |
| `scause` (Supervisor Cause Register) | 保存中断或异常的类型和来源（中断or异常，编号多少）。       | 记录“出事的原因”               |
| `stval` (Supervisor Trap Value)      | 提供额外上下文，比如故障地址、访问页表失败地址等。         | 记录“案发遗留物”（如故障地址） |



##### 	1.4.3 中断使能与屏蔽逻辑

​	该部分讲的是中断前的判断“中断能不能发生、什么时候允许发生”。属于中断响应前的调度与防御机制。在操作系统修改共享数据结构或切换任务时，需要一个“不被打断的安全窗口”，必须在某些时刻阻止CPU响应新中断。

​	为了实现这个功能，RISC-V提供了两个层级的控制：

- 全局中断使能/禁用（一个总开关）
- 逐类中断的屏蔽开关（细粒度控制）

下面分别详细讲讲这两个层级：

###### ①、sstatus 寄存器中的中断控制位（全局级）：

sstatus是S模式下的核心状态控制寄存器，其中跟中断相关的字段：

| 字段名           | 含义                                 | 行为                                                |
| ---------------- | ------------------------------------ | --------------------------------------------------- |
| **SIE (bit 1)**  | Supervisor Interrupt Enable          | 控制是否允许 S 模式响应中断。为 1 开启；为 0 禁止。 |
| **SPIE (bit 5)** | Supervisor Previous Interrupt Enable | 保存陷入前 SIE 的旧值。                             |
| **SPP (bit 8)**  | Supervisor Previous Privilege        | 记录陷入前 CPU 的特权级：0=U 模式，1=S 模式。       |

- SIE：中断总电源，当SIE=0，即使外设产生了中断信号，CPU也不会响应。
- SPIE：会记录进入S模式之前的SIE值。当CPU从U模式—>S模式 或 S模式->S模式：

| 操作阶段                       | sstatus.SIE        | sstatus.SPIE    |
| ------------------------------ | ------------------ | --------------- |
| 进入 Trap 时（硬件自动）       | 清 0（中断被禁止） | 保存旧的 SIE 值 |
| 执行中断处理程序               | 0（防止嵌套中断）  | 保留旧值        |
| 执行 `sret` 返回前（硬件自动） | 由 SPIE 恢复       | SPIE 置为 1     |

这样，硬件自动为内核提供了一个“自动暂时关闭中断 → 处理 → 自动恢复”的完整闭环。

- SPP：储存“陷入前的特权级”。
  - SPP=0-->从U模式陷入，被处理完后sret返回U模式
  - SPP=1-->从S模式陷入，被处理完后sret返回S模式

###### ②、sie寄存器（中断选择级）：

sie提供细粒度控制，允许内核“只开部分中断”。可以将SIE看作“总阀门”，sie看作“分支阀门”。



##### 	1.4.4 完整流程：

首先处于U模式的程序，可能因为三类原因触发陷入：

| 触发类型              | 举例                       | 触发方式 |
| --------------------- | -------------------------- | -------- |
| **系统调用（ecall）** | 用户程序主动请求 OS 服务   | 主动陷入 |
| **中断（Interrupt）** | 定时器中断、外设中断       | 被动陷入 |
| **异常（Exception）** | 缺页、非法访问、非法指令等 | 被动陷入 |

一旦CPU决定陷入，它会在不经过软件参与的情况下自动完成以下动作：

###### ①、保存关键信息：将PC、中断原因、补充信息分别保存在寄存器sepc、scause、stval中。

###### ②、保存与修改中断状态：使用SIE、SPIE、SPP记录使能状态。

###### ③、切换执行环境：CPU完成“身份切换”。

| 项               | 从                   | 到                            |
| ---------------- | -------------------- | ----------------------------- |
| 特权级           | U 模式               | S 模式                        |
| PC（程序计数器） | 原用户程序处（sepc） | 由 `stvec` 决定的内核入口地址 |

此处的stvec由操作系统事先设置，是 S 模式 Trap Handler 的入口点。并且根据“stvec.mode=00||01”选择不同模式：

- Direct 模式（stvec.mode = 00）：所有陷阱进同一入口。
- Vectored 模式（stvec.mode = 01）：根据 scause 的值跳转不同偏移。

接着操作系统开始接手（软件阶段）。



### 2、操作系统与硬件的交界面

​	先总结一下整个过程：当硬件中断或异常发生，CPU会跳转到stvec指定的入口（_alltraps），也就是中断入口点。在将寄存器压入栈之前，汇编先用“”csrw sscratch，sp“将当前栈顶指针sp保存到CSR sscratch中，这样在中断返回时可以恢复原用户栈指针，确保栈环境不被破坏。接着调用SAVE_ALL宏将CPU记录的32个GPR和4个CSR按当前顺序压入当前内核栈，形成一块连续的trapframe数据。接下来，中断入口汇编代码会将当前内容栈顶（也就是trapframe的起始地址sp）作为参数传入a0寄存器，并调用C语言编写的中断处理函数trap（）。接着执行sret，硬件会根据sstatus.SSP恢复到陷入前的特权级，并将sepc的内容加载到pc，从而重新返回到被中断的用户指令处继续执行。

​	总的说来就是一条从**硬件中断**到**汇编入口**到**内核C逻辑**的调用路径。

​	阶段总结表如下所示：

| 阶段             | 执行者              | 主要工作                                                   |
| ---------------- | ------------------- | ---------------------------------------------------------- |
| **陷入阶段**     | 硬件                | 保存 sepc / scause / stval，切换特权级 (U → S)，跳转 stvec |
| **汇编入口阶段** | 汇编 (`__alltraps`) | SAVE_ALL 保存上下文，形成 trapframe                        |
| **中断处理阶段** | C 函数 (`trap(tf)`) | 判断中断类型并处理，修改 trapframe                         |
| **返回阶段**     | 汇编 (`__trapret`)  | RESTORE_ALL 恢复，执行 sret 返回用户程序                   |

如下是伪代码表示：

```

    .globl __alltraps

.align(2) #中断入口点 __alltraps必须四字节对齐
__alltraps:
    SAVE_ALL #保存上下文

    move  a0, sp #传递参数。将栈顶地址用a0寄存器记录，此时trapframe结构体的起始地址就是sp，后续调用trap()就可以用sp调用。
    #按照RISCV calling convention, a0寄存器传递参数给接下来调用的函数trap。
    #trap是trap.c里面的一个C语言函数，也就是我们的中断处理程序
    jal trap 
    #trap函数指向完之后，会回到这里向下继续执行__trapret里面的内容，RESTORE_ALL,sret

    .globl __trapret
__trapret:
    RESTORE_ALL
    # return from supervisor call
    sret
```



#### 2.1 初始化中断入口

​	通过设置stvec寄存器，让所有中断和异常都跳转到同一个入口函数_alltraps。并且使用Direct模式，让所有中断都进入同一个入口点。



#### 2.2 保存“CPU”上下文	

- 定义一个**trapframe结构体**来统一描述CPU的寄存器状态。其中包含32个GPR（通用寄存器）+4个和中断有关的CSR（控制与状态寄存器）（如sstatus、sepc、stval、scause）

  ```
  csrw sscratch, sp #保存原先的栈顶指针到sscratch
  ```

- 将原先的栈顶指针sp保存到 csrw sscratch中，这样在中断返回时可以恢复原用户栈指针，确保栈环境不被破坏。
- 用汇编宏SAVE_ALL把这36个寄存器压入栈中（构建出一块trapframe数据）。
- 栈顶此时保存的是一个完整“事件快照”，相当于冻结了中断时 CPU 的全部状态。



#### 2.3 调用C层处理函数trap（）

- 通过寄存器a0传递trapframe的指针给C函数trap（），如下列代码：

```
move  a0, sp //将当前的指针sp（trapframe的首地址）作为参数传入a0
jal   trap   //调用trap
```



```
void trap(struct trapframe *tf) {
    printk("sepc = %lx, scause = %lx\n", tf->epc, tf->cause);
}
```



- trap（）函数就是内核中断分发函数：它可以通过参数tf'（即sp）直接访问刚刚保存的CPU上下文，包括通用寄存器GPR和关键CSR的内容，比如读取scause、判断事件类别（系统调用/定时器中断/页错误等），再执行相应逻辑。



#### 2.4 恢复“CPU上下文”并返回用户态

```
  .globl __trapret
__trapret:
    RESTORE_ALL         //把栈上的寄存器按顺序恢复，恢复CSR（sstatus、sepc），恢复指针sp为中断发生前的用户栈地址
    # return from supervisor call
    sret           //根据sstatus.SPP决定返回特权级等，如下列描述。
```

​	当 “jal trap”返回，CPU会执行“_trapret”标号，

- 用宏RESTORE_ALL按原顺序取回所有寄存器
- 根据中断类型恢复并调整sepc
- 确保 sstatue.SPP=0（回到用户态）、sstatus.SPIE 恢复中断状态（可以下一次中断）。
- 执行特权指令 sret：

​    	切换回U模式-->PC<-sepc （回到用户程序）-->进行执行



### 3、中断处理流程（框架下的实现）

#### 3.1 init.c--“开机初始化”

​	在中断处理之前，首先需要在“init.c”中调用初始化的函数。

```
 write_csr(sscratch, 0);
 write_csr(stvec, &__alltraps);
 void intr_enable(void) { set_csr(sstatus, SSTATUS_SIE); }
```

​	对于中断处理部分的约定：

- 若中断前处于S态，sscratch为0
- 若中断前处于U态，sscratch存储内核栈地址

​	之后可以通过sscratch判断是内核态产生的中断还是用户态产生的中断。因为此时处于S内核态，所以在初始化阶段将sscratch设为0，接着将 alltraps的地址传入stvec，跳转到 alltraps入口。接着打开“intr_enable”开关，允许中断能够生效。



#### 3.2 trap.c--"中断入口的C层桥梁"

```
void trap(struct trapframe *tf) { trap_dispatch(tf); }
```

​	在进入“alltraps”入口之后，调用该trap函数，其中的tf就是上述提到的sp栈顶，根据栈中的scause先判断是中断处理还是异常处理，将工作分发给interrupt_handler()，exception_handler()

```
//scause的最高位是1，说明trap是由中断引起的
    if ((intptr_t)tf->cause < 0) {
        // interrupts
        interrupt_handler(tf);
    } else {
        // exceptions
        exception_handler(tf);
    }
```



#### 3.3 响应事件部分

​	通过scause判断中断类型后，通过interrupt_handler()和exception_handler()真正实现trap函数，进行中断操作。

| scause 值 | 异常类型                               | 说明                    |
| --------- | -------------------------------------- | ----------------------- |
| 0         | 指令地址未对齐异常                     | 取指地址不是 4 字节倍数 |
| 1         | 指令访问错误                           | 访问非法内存            |
| **2**     | **非法指令异常 (Illegal Instruction)** | 执行了 CPU 不支持的指令 |
| **3**     | **断点异常 (Breakpoint)**              | 执行 `ebreak` 指令      |
| 5         | 加载访问异常                           | load 访问错误           |
| 7         | 存储/写入访问异常                      | store 访问错误          |

##### 3.3.1 练习1--中断处理部分：

​	其中在中断处理部分补充以下代码，可以实现此次实验**练习1**中的部分，使操作系统每遇到100次时钟中断调用打印函数，打印10次后关机。

```
  clock_set_next_event();         //设置下一次时钟中断;
            state size_t ticks =0;          //设置局部静态变量，保存时钟中断次数；
            ticks++;                        //每收到一次中断，ticks+1；

            if(ticks % TICK_NUM==0){        //当触发100次中断，上述定义”#define TICK_NUM 100“
                print_ticks();              //调用print_ticks()，打印“100 ticks”
                num++;                      //num表示打印的次数;
            }

            if(num==10){
                sbi_shutdowm();             //当打印次数=10，调用sbi_shutdowm（）关机。
            }

```



##### 3.3.2 扩展练习3--异常处理部分：

​	根据实验要求，要在异常处理部分补充上“Illegal instruction”和“breakpoint”两种异常处理类型，并且输出异常指令地址，更新tf->epc寄存器，保存异常发生时的指令地址，若不修改该寄存器，那么返回时会回到原地址，出现死循环。

​	具体修改如下列所示：

```
case CAUSE_ILLEGAL_INSTRUCTION:
 	cprintf("Exception type: Illegal instruction\n");
    cprintf("Illegal instruction at 0x%lx\n", tf->epc); //"0x%lx"表示的是打印一个64位无符号长整数（即地址值），以十六进制格式输出。后面的“tf->epc”表示的是异常发生时，CPU自动保存的寄存器sepc的值。
    tf->epc += 4;  // 跳过这条非法指令，因为在RISC-V里指令宽度为4，所以此处通过+4跳过指令。
    break;
    
case CAUSE_BREAKPOINT:
 	cprintf("Exception type: breakpoint\n");
    cprintf("Breakpoint at 0x%lx\n", tf->epc);
    tf->epc += 4;  // 同样跳过断点指令
    break;

```

​	因为此时还不能使用标准C库的printf，所以使用内核态的函数cprintf打印类型、地址。



### 4、时钟中断

### 5、中断的关闭和开启

