# Lab1 实验报告

- 姓名：杨竣羽
- 学号：2313043
- 实验仓库：[oswhy-group](https://github.com/oswhy-group)
- 本次实验目录：`labcodes/lab1/`

------

## 一、实验目的与要求

实验目的：

- 理解最小可执行内核的基本结构和启动流程。
- 掌握 QEMU 模拟器环境下的 RISC-V 系统启动机制。
- 学会使用链接脚本控制内存布局、交叉编译和生成内核镜像的方法。
- 能够利用 OpenSBI 作为 bootloader 启动内核，并通过 Qemu 进行模拟及调试。
- 熟悉在内核中调用 OpenSBI 服务进行格式化字符串输出。

实验要求：

- 要求：完成练习，在报告中回答每个练习提出的问题；将代码与报告一并提交至仓库。

------

## 二、实验环境

- OS： Linux Ubuntu
- 工具链：gcc/clang、make、qemu、gdb
- 其他：必要的依赖与脚本
- 实验环境配置过程：

​	根据老师给出的配置环境，跳过配置过程，出现如图所示的画面说明环境配置成功。
<img src="D:\学习\大三上\操作系统\OSLAB-2025\YangJunyu\Lab1\image-20251008164242541.png" alt="image-20251008164242541" style="zoom:67%;" />

------

## 三、项目组成和执行流

> 提供的树形目录结构如下所示：

~~~text
```text
D:.
|   Makefile
|   tree.txt
|   实验报告.md
|   
+---kern
|   +---driver
|   |       console.c
|   |       console.h
|   |       
|   +---init
|   |       entry.S
|   |       init.c
|   |       
|   +---libs
|   |       stdio.c
|   |       
|   \---mm
|           memlayout.h
|           mmu.h
|           
+---libs
|       defs.h
|       error.h
|       printfmt.c
|       readline.c
|       riscv.h
|       sbi.c
|       sbi.h
|       stdarg.h
|       stdio.h
|       string.c
|       string.h
|       
\---tools
        function.mk
        kernel.ld
        

~~~

- `kern/`：内核代码，各子目录是不同子系统
- `libs/`：C库和工具代码
- `tools/`：工具和脚本
- `Makefile`：编译主脚本
- `实验报告.md`：本次实验报告



------

## 四、练习与问题回答

### 练习1：对entry.s（操作系统内核启动汇编入口文件）的分析

- 我的回答：
  - 指令la sp,bootstacktop中la表示“load address”，把bootstacktop这个符号的地址加载到寄存器sp（stack pointer堆栈指针）中。其目的是将sp指向静态分配的内存区域bootstack，从top开始，为之后函数调用/局部变量分配提供合理区域。
  - tail kern_init作用是无条件跳转到内核C初始化函数kern_init的入口处。其中tail含义是无条件跳转到；kern_init是跳转且不会返回。所以组合起来就是无条件跳转到kern_init，并且不回头，即内核初始化完成后就进入主循环。目的是保证初始化汇编部分的代码在完成任务后无需返回，实现了内核从汇编到C代码的自然衔接。

------

### 练习2：使用GDB验证启动流程



- 操作过程：

  首先先在Ubuntu里编译实验代码，如图所示。生成后续所需的内核镜像文件。

  <img src="C:\Users\yangjy\AppData\Roaming\Typora\typora-user-images\image-20251008181037181.png" alt="image-20251008181037181" style="zoom:54%;" />

​	接着用启动QEMU并开启GDB调试端口。出现如图所示的界面代表GDB已经成功连接到了QEMU的调试端口。接着通过x/10i $pc查看当前PC附近的汇编指令。

```
qemu-system-riscv64 -machine virt -nographic -bios none -kernel Image -s -S   #-s表示在1234端口监听GDB；  -S表示启动后暂停，等待GDB连接。
```

​	接着用GDB连接QEMU并加载符号

```
riscv64-unknown-elf-gdb Image
(gdb) target remote :1234
```



<img src="C:\Users\yangjy\AppData\Roaming\Typora\typora-user-images\image-20251008183148312.png" alt="image-20251008183148312" style="zoom:55%;" />

	发现即将执行的汇编指令为：
	   0x1000:	auipc	t0,0x0   #t0=0x1000
	   0x1004:	addi	a1,t0,32   #t0=0x1020
	   0x1008:	csrr	a0,mhartid   #读取当前硬件线程ID，写入a0；
	   0x100c:	ld	t0,24(t0)     #t0=[t0+24],读取8字节数据。
	   #以上
	   0x1010:	jr	t0
	   0x1014:	unimp
	   0x1016:	unimp
	   0x1018:	unimp
	   0x101a:	0x8000
	   0x101c:	unimp
	
	接着使用si单步执行以及使用info r t0查看t0寄存器中的内容。如下列所示：
	(gdb) si
	0x0000000000001004 in ?? ()
	(gdb) info r t0
	t0             0x1000	4096
	(gdb) si
	0x0000000000001008 in ?? ()
	(gdb) info r t0
	t0             0x1000	4096
	(gdb) si       
	0x000000000000100c in ?? ()
	(gdb) info r t0
	t0             0x1000	4096
	(gdb) si       
	0x0000000000001010 in ?? ()
	(gdb) info r t0
	t0             0x80000000	2147483648  ===>这个时候由于经过0x100c，执行了"ld,t0,24(t0)"，t0寄存器里的值改变
	(gdb) si
	0x0000000080000000 in ?? ()
	(gdb) 

​	此时已经跳转到0x0000008000000地址处，还需要加载操作系统的内核并启动操作系统，由于实验手册已经给出提示，该过程直到跳转到0x00008020000结束，所以需要在改地址处打上断点。同时为了探究跳转过程中各部分的功能，所以还需要从0x0080000之后开始观察，所以用x/10i 0x80000000显示该地址处的10个数据。如下所示

```
   0x80000000:	csrr	a6,mhartid  #将当前硬件线程的ID存入寄存器a6
   0x80000004:	bgtz	a6,0x80000108   #若a6>0，跳转到0x80000108
   0x80000008:	auipc	t0,0x0    #t0=当前pc+0，即t0=0x80000008
   0x8000000c:	addi	t0,t0,1032   #t0=t0+1032 ==>（1032）10==（0x408）16   t0=0x80000008+0x408=0x80000410
   0x80000010:	auipc	t1,0x0   #t1=0x80000410
   0x80000014:	addi	t1,t1,-16   #t1=t1-16=0x80000000
   0x80000018:	sd	t1,0(t0)     #将t1地址的数据存在t0处
   0x8000001c:	auipc	t0,0x0    #t0=0x8000001c
   0x80000020:	addi	t0,t0,1020   #t0=t0+1020=t0+0x3FC=0x80000418
   0x80000024:	ld	t0,0(t0)   #从0x80000418加载一个双字到t0.

```

​	接着在内核入口打上断点，可以使用如下代码完成断点。

```
 break kern_entry #在kern_entry的开头打上断点。
```

​	输出如下所示：

```
Breakpoint 1 at 0x80200000: file kern/init/entry.S, line 7.
```

​	代表在kern/init/entry.S 的第七行打上了断点Breakpoint。、

​	接着使用“continue”指令继续执行，让代码运行到断点位置。通过“x/10i $pc”查看此时位置的汇编代码，如下所示：

```
(gdb) x/10i $pc
=> 0x80200000 <kern_entry>:	auipc	sp,0x3  #sp=pc+(0x3<<12)=0x80203000
   0x80200004 <kern_entry+4>:	mv	sp,sp
   0x80200008 <kern_entry+8>:	j	0x8020000a <kern_init>  #跳转到内核初始化函数的入口（kern_init）
   0x8020000a <kern_init>:	auipc	a0,0x3   #a0=pc+(0x3<<12)=0x8020300a
   0x8020000e <kern_init+4>:	addi	a0,a0,-2   #a0=a0-2=0x80203008
   0x80200012 <kern_init+8>:	auipc	a2,0x3    #a2=a2+(0x3<<12)=0x80203012
   0x80200016 <kern_init+12>:	addi	a2,a2,-10   #a2=a2-10=0x80203008
   0x8020001a <kern_init+16>:	addi	sp,sp,-16   #sp=sp-16=0x80202ff0 
   0x8020001c <kern_init+18>:	li	a1,0      #a1=0
   0x8020001e <kern_init+20>:	sub	a2,a2,a0    #a2=0

```

​	发现这段输出是内核的启动入口和初始化代码。

​	接着在kern_init上打上断点：

```
break kern_init
```

​	出现以下输出：

```
Breakpoint 2 at 0x8020000a: file kern/init/init.c, line 8.  #说明已经在kern_init的入口（init.c的第8行，0x8020000a）成功设置第二个断点。
```

​	继续continue，通过“disassemble kern_init”查看反汇编C代码对应的指令，如下列所示：

```
   0x000000008020000a <+0>:	auipc	a0,0x3   #a0=pc+(0x3<<12)=0x8020300a
   0x000000008020000e <+4>:	addi	a0,a0,-2 # a0=a0-2=0x80203008
   0x0000000080200012 <+8>:	auipc	a2,0x3    #a2=pc+(0x3<<12)=0x80203012
   0x0000000080200016 <+12>:	addi	a2,a2,-10   #a2=a2-10=0x80203002 
   0x000000008020001a <+16>:	addi	sp,sp,-16   #sp=sp-16(在栈上分配16字节的空间)
   0x000000008020001c <+18>:	li	a1,0     #a1=0  ,将0加载到a1寄存器;
   0x000000008020001e <+20>:	sub	a2,a2,a0    #a2=a2-a0=0x80203002-0x80203008=-6
   0x0000000080200020 <+22>:	sd	ra,8(sp)    #将ra的值存储到[sp+8]上
   0x0000000080200022 <+24>:	jal	ra,0x802004b6 <memset>    #跳转到memset，并保存返回地址到ra
   0x0000000080200026 <+28>:	auipc	a1,0x0     #a1=pc+(0x0<<12)=0x80200026
   0x000000008020002a <+32>:	addi	a1,a1,1186 # 0x802004c8    #a1=a1+1186=0x802004c8
   0x000000008020002e <+36>:	auipc	a0,0x0   #a0=pc+(0x0<<12)=0x8020002e
   0x0000000080200032 <+40>:	addi	a0,a0,1210 # 0x802004e8   #a0=a0+1210=0x802004e8
   0x0000000080200036 <+44>:	jal	ra,0x80200056 <cprintf>    #跳转到cprintf,执行打印功能
   0x000000008020003a <+48>:	j	0x8020003a <kern_init+48>   #跳转到kern_init+48位置，即程序的入口点加上48字节的偏移，也就是跳转到自己本身，形成一个无限循环
End of assembler dump.    #表示汇编转储结束，即汇编代码已经展示完毕

```







<img src="C:\Users\yangjy\AppData\Roaming\Typora\typora-user-images\image-20251009003143211.png" alt="image-20251009003143211" style="zoom:65%;" />

- 我的回答：

​	根据上述的实验，发现RISC-V加电最初执行的指令位于0x1000。

​	指令完成的功能可以分为以下几个阶段：

###### 读取CPU核心编号：

“csrr a0,mhartid"，读取硬件hart id，为多核引导做准备

###### 解析/计算并定位bootloader的入口地址：

"ld t0,24(t0)   #读取8字节数据"

"jr    t0"    ---->取出bootloader的起始地址并跳转执行（跳转到DRAM区的OpenSBI主体），进行系统级初始化。

###### 切换到内核运行态(S)并跳转到内核入口（0x80200000）

内核从0x80200000开始执行第一条指令，通常首先完成内核栈的初始化与早期内存区的清零，并跳转到 `kern_init` 等 C 语言初始化入口。

​	至此，从加电到内核启动的引导路径闭环：0x1000(复位/引导片段)->0x80000000(OpenSBI主体初始化)->0x80200000(内核第一条指令)。

------

