```c++
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        cprintf("Max process limit reached!\n");
        goto fork_out;
    }
    ret = -E_NO_MEM;
    // LAB4:EXERCISE2 2313043
    /*
     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
     * MACROs or Functions:
     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)
     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack
     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags
     *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"
     *   copy_thread:  setup the trapframe on the  process's kernel stack top and
     *                 setup the kernel entry point and stack of process
     *   hash_proc:    add proc into proc hash_list
     *   get_pid:      alloc a unique pid for process
     *   wakeup_proc:  set proc->state = PROC_RUNNABLE
     * VARIABLES:
     *   proc_list:    the process set's list
     *   nr_process:   the number of process set
     */

    //    1. call alloc_proc to allocate a proc_struct
    //    2. call setup_kstack to allocate a kernel stack for child process
    //    3. call copy_mm to dup OR share mm according clone_flag
    //    4. call copy_thread to setup tf & context in proc_struct
    //    5. insert proc_struct into hash_list && proc_list
    //    6. call wakeup_proc to make the new child process RUNNABLE
    //    7. set ret vaule using child proc's pid
    proc = alloc_proc();
    if(proc == NULL) 
    {
        cprintf("proc allocation failed\n");
        goto fork_out;

    }
    cprintf("Allocated proc_struct: %p\n", proc); 
    
    if(setup_kstack(proc) != 0){
        cprintf("setup_kstack failed for proc: %d\n", proc->pid);
        goto bad_fork_cleanup_proc;
    }

    if(copy_mm(clone_flags,proc)!=0){
        cprintf("copy_mm failed for proc: %d\n", proc->pid);
        goto bad_fork_cleanup_kstack;
    }

    copy_thread(proc,stack,tf);

    proc->pid = get_pid();
    if (proc->pid < 0) {
        cprintf("Failed to get a PID for proc\n");
        goto bad_fork_cleanup_mm; 
    }

    proc->parent = current;
    hash_proc(proc);
    list_add(&proc_list,&(proc->list_link));
    nr_process++;

    wakeup_proc(proc);

    return proc->pid;


fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_mm:
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```



```c++
int do_exit(int error_code)
{
    struct proc_struct *parent = current->parent;

    exit_mmap();
    exit_pgdir();
    mm_destroy();

    current->state = PROC_ZOMBIE;
    wakeup_proc(parent);
    schedule();
}
```





```c++
trapframe和context:

struct trapframe {
    struct pushregs gpr;  //通用寄存器状态，包含了从x0到x31的所有通用寄存器的值
    uintptr_t status; //sstatus
    uintptr_t epc; //sepc，程序计数器
    uintptr_t badvaddr; //sbadvaddr，访问错误地址
    uintptr_t cause; //scause，记录中断原因。
};


struct context
{
    uintptr_t ra;  //Return Address（返回地址寄存器）
    uintptr_t sp;  //Stack Pointer（栈顶指针）
    uintptr_t s0;  //s0--s11都是通用寄存器。
    uintptr_t s1;
    uintptr_t s2;
    uintptr_t s3;
    uintptr_t s4;
    uintptr_t s5;
    uintptr_t s6;
    uintptr_t s7;
    uintptr_t s8;
    uintptr_t s9;
    uintptr_t s10;
    uintptr_t s11;
};

```

